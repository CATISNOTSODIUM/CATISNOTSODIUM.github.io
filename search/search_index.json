{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Thitiwat Kosolpattanadurong","text":""},{"location":"#about-me","title":"About me","text":"<p>I'm currently a Computer Science student at National University of Singapore (NUS). I'm used to be a physics enjoyer, participating in the International Physics Olympiad (IPhO). However, my interest shifted towards software engineering, programming languages, and algorithms. </p>"},{"location":"#interests","title":"Interests","text":"<ul> <li>Parallel Programming</li> <li>Programming Language development</li> <li>Software Development</li> <li>Running</li> </ul>"},{"location":"#teaching-assistant","title":"Teaching Assistant","text":"<p>CS1101S Teaching Assistant AY 25/26 Sem 1 Prepare studio materials and conduct weekly two-hour tutorial sessions for students. You can read my blog here.</p>"},{"location":"#work-experiences","title":"Work Experiences","text":"<p>Software Developer at Computing for Voluntary Welfare Organisations (CVWO) May 2025 - Present | SQL, Bash, Go, React Native, Redux  Migrated the Home Personal Care (HPC) module from Ruby on Rails to Go, and developed SQL scripts to transfer data from the original infrastructure to the new system for data exports. Developing a mobile app to facilitate consent requests from Next of Kin for Kwong Wai Shiu Hospital (KWSH), integrated with the existing CVWO-AAC system.</p> <p>Software Developer at Source Academy Jan 2025 - May 2025 | TypeScript (ESTree)  A one-semester project-based course (CP3108A) to improve Source Academy, a platform for NUS programming introductory courses (CS1101S). Please refer to this section for more details.</p> <p>Software Developer Intern at Lenor Sep 2024 - Dec 2024 | Express, Flask  Developed and implemented an API management system for an essay grading platform. Trained generative adversarial network (GAN) model for strikethrough removal from student essays, improving the essay grading performance.</p> <p>Part-time Full-stack Developer at Association of Thai Students in Singapore (ATSIS) Sep 2024 - Jun 2025 | Next JS  Developed and maintained the official website for Thai students in Singapore. Developed an E-Card component for the ATSIS student membership system, enabling digital membership verification and streamlined access to exclusive benefits.</p>"},{"location":"#open-source-contributions","title":"Open Source Contributions","text":""},{"location":"#source-academy","title":"Source Academy","text":"<p>Enhancing Stepper (Reduction-based Substitutor) Jan 2025 - May 2025 | js-slang PR |  Frontend PR | Mu term documentation</p> <ul> <li>Collaborated on the reimplementation of stepper, a step-by-step program execution visualization tool, adhering to reduction logic to ensure correctness and enhance source code maintainability.</li> <li>Creating a React custom code renderer from ESTree (inspired by <code>react-ace</code> and <code>astring</code> libraries) for the new stepper. You can try it out here. Make sure that you select Source \u00a71 or 2 and select the double arrow tab on the right to play with stepper.</li> </ul>"},{"location":"#personal-projects","title":"Personal Projects","text":"<p>BOF - An esoteric programming language (BF) with macros Typescript | Github  BOF is a BF interpreter with high level features such as variable declarations, assignments, macros and recursion. BOF uses recursive descent parsing with stack-based machine to interpret the program.</p> <p><code>lenor-strikethrough-identifier</code> - A strikethrough identification server for essay grading Flask | Github  A backend for identifying strikethrough images by using generative adversarial network (GAN) model. This is a part of my Lenor internship.</p>"},{"location":"#high-school-competitions","title":"High school competitions","text":""},{"location":"#olympiads","title":"Olympiads","text":"<ul> <li>International Physics Olympiad (IPhO) - Silver Medal  2022 | Switzerland (Online) </li> <li>Asian Physics Olympiad (APhO) - Honourable Mention  2022 | India (Online) </li> <li>Thailand Physics Olympiad (TPhO) - Gold Medal  TPhO 20 | Thailand </li> <li>Thailand Mathematics Olympiad (TMO) - Silver Medal  TMO 17, 18 | Thailand </li> </ul>"},{"location":"#mathematical-modeling","title":"Mathematical Modeling","text":"<p>Mathematical modeling competition is a team competition that encourages students to come up with mathematical models to solve real-world problems under limited days (5 days for IMMC, 2 weeks for HiMCM). This is definitely one of my favourite types of competition. Props to all of my teammates for carrying the team!</p> <ul> <li> <p>The 2022 International Mathematical Modeling Challenge (IMMC) - Outstanding Award  Task: Aboard! Boarding and Disembarking a Plane | Our Solution  A finite automata model for evaluating the efficiency of various boarding and disembarking strategies </p> </li> <li> <p>The 2024 International Mathematical Modeling Challenge (IMMC) - Finalist Award  Task: Picking the Perfect Pet  A decision model (FAHP) for selecting the ideal pet based on factors such as household income and geographic location.</p> </li> <li> <p>The 2023 High School Mathematical Contest in Modeling (HiMCM) - Finalist Award  Task: Dandelions  Developed a finite automata model to predict and analyze the ecological and economic impacts of dandelion (Taraxacum officinale) proliferation.</p> </li> </ul>"},{"location":"blogs/","title":"Blogs","text":"<p>Here is a compilation of all my writings.</p>"},{"location":"blogs/#nus-related-blogs","title":"NUS Related Blogs","text":"<ul> <li>NUS Modules Review</li> <li>Reimplementing Stepper</li> </ul>"},{"location":"blogs/#algorithm-dump","title":"Algorithm Dump","text":"<p>Some notes to myself when I want to review these concepts in the future.</p> <ul> <li>Minimizing the sum of the minimum and maximum edge weights along a path.</li> </ul>"},{"location":"blogs/#miscelleneous","title":"Miscelleneous","text":"<ul> <li>Running Journey</li> </ul>"},{"location":"blogs/CS1101S/","title":"CS1101S Teaching Experience","text":"<p>The most beautiful program ever written, in my opinion, is the Eval/Apply Interpreter.  Gerald Jay Sussman</p> <p>I used to have an overarching love-hate relationship with this module solely due to the overemphasis on Programming-language related stuff which is not beginner friendly. However, this module perfectly serves as a starter pack for someone to dig dive to programming-language specialization which started to be one of my personal interests two-months after the course had ended. I felt like my job was to inspire people to think in the same way, and that's the reason I decided to apply for CS1101S TA.</p> <p></p> <p>The picture above summarizes what I had to teach for this course. CS1101S focuses a lot of stuff related to programming world. Language construct and problem solving, in my opinion, are the takeaway I want my students to achieve after this course. Understanding tricky programming-language concept itself a bonus.</p> <p>Now, speaking of the teaching itself, the most important aspect that I have learned from teaching is to focus on simple examples, avoid generalization from the start, and provide sufficient intuition for students to work on. You can see the example from the solution slide here for the <code>subset</code> question.</p> <p>(To be written)</p> <p>Here are all of my teaching materials for CS1101S weekly studio sessions.</p> <ul> <li>Studio S2: Introduction:   Notes |  Slides</li> <li>Studio S3: Substitution model: Notes |   Order of Growth - Notes |  Slides</li> <li>Studio S4: Higher order function: Slides</li> <li>Studio S5: Pair and list: Slides</li> <li>Studio S6: List operations: Slides</li> <li>Studio S7: Midterm review: Slides</li> <li>Studio S8: Streams: Slides</li> <li>Studio S9: Environment model: Slides</li> <li>Studio S11: Arrays: Slides</li> <li>Studio S12: CSE Machine: Slides</li> <li>Studio S13: Metacircular Evaluator: Slides</li> </ul>"},{"location":"blogs/NUS_modules_review/","title":"NUS Modules Review","text":""},{"location":"blogs/NUS_modules_review/#nus-modules-taken","title":"NUS Modules Taken","text":"<p>A list of relevant (Math and CS) modules I have taken in NUS. </p> AY 24/25 Semester 1 (Dean's list) <ul> <li>CS1101S (A+, top student)</li> <li>CS1231S (A+, top student)</li> <li>MA1521 (A+)</li> <li>ST1131 (A)</li> </ul> AY 24/25 Semester 2 (Dean's list) <ul> <li>CS2100 (A+)</li> <li>CS2030S (A+)</li> <li>CS2040S (A+)</li> <li>MA1522 (A+)</li> <li>ST2334 (A+)</li> </ul> AY 25/26 Semester 1 <ul> <li>CS2103T (A-)</li> <li>CS2104 (B+)</li> <li>CS2106 (A+)</li> <li>CS3230 (A)</li> </ul>"},{"location":"blogs/NUS_modules_review/#cs2030s-programming-methodology-ii","title":"CS2030S - Programming Methodology II","text":"<p>Personally, the content of this module was well organized. The community (Ed discussion) was very active, and the lecturers were really great (preferably among the best I've taken in Y1). Programming exercises were a little bit challenging, but if you know what you are trying to do, it's not that bad. Even though it is not compulsory to complete all exercises in this semester, it's still a great exercise for students to familarize students with OOP and FP paradigms in one semester. Forcing students to use Vim was also one of the best decisions in my opinion. Although the getting used to it is very hard, It's really worth if you want to code faster.</p> <p>However, the exams and PEs hindered me from enjoying this module. The exams (especially midterm) had a lot of typos, and the wrongly implemented min function in PE1 wrecked many students so bad, including me. Moreover, the infamous XOR question that aimed to test monad can posed unfair advantages for students who knew XOR before (either from CS2100 or other stuffs). Even though voiding these questions might seem unfair, I felt the lecturers should have taken more responsibility in setting them or at least conducted a thorough recheck of the exam.</p>"},{"location":"blogs/NUS_modules_review/#ma1522-linear-algebra-for-computing","title":"MA1522 - Linear Algebra for Computing","text":"<p>A very interesting introductory linear algebra module that covers wide range of topics, including concepts like eigenspaces and SVD decomposition. This is a hybrid module, where lecture contents were prerecorded and the actual f2f lecture slot served as a recitation session. Though the f2f lecture was not mandatory, it's a pretty great session for me to revise the content learnt throughout the videos. In addition, the lecturer spent some time going through exercises and optional challenges which were mostly proof-based. Even though this course does not require you to write any proofs (spoken by the lecturer himself), going through proofs really helped be consolidate my thoughts and make this course more fulfilling.</p> <p>Speaking of the lecturer, he was very kind and dedicated to his teaching. Even though his teaching style was a little bit dry compared to previous iterations of this module, he's still great and very friendly. I also had some small talks with him before the session in later weeks. It's kinda sad that not many people did attend his lecture. I wish more people attended his lecture in the future.</p> <p>Assessments - A lot of lecture quiz (it gets kinda annoying at times) - Three written assignments (The question style was similar to tutorial questions) - Final Exam: Not that hard. The difficulty of the questions was similar to assignment questions.</p> <p>Overall, this is a great module. It becomes abstract at times, but it remains manageable with decent effort.</p>"},{"location":"blogs/NUS_modules_review/#cs2100-computer-organisation","title":"CS2100 Computer Organisation","text":"<p>What an interesting roller coaster ride! This module is infamous for being one of the most annoying modules among trinity modules, and it actually is. Since all video contents were pre recorded, it\u2019s recommended to stay ahead of the lecture a week or two, especially when you took it with CS2030s and CS2040s (in case you want to take trinity)</p> <p>Now, let\u2019s talk about the module itself. The content before the midterm was a whirlwind tour to number systems, C programming, and MIPS Processor. I really loved how the lecturer spent two weeks on MIPS since it\u2019s very relevant to what we might encounter in the future. Moreover, these topics were pretty fascinating for me, and I actually enjoyed every bit (no pun intended) of them and I expected to keep this feeling until the end of this semester. Not until I opened some past year's midterm papers, I then realized that the difficulty of this module did not come from the content itself, but the awkwardness of how these concepts were tested. Luckily, this semester\u2019s midterm paper is not that bad. The median was also really high this semester (26.5/40).</p> <p>For the second half of the semester, we were introduced to boolean algebra, combinatorial circuits, MSI components, and Sequential circuits. Personally, I found this section to be a little dry due to its nature of the subject and I found these topics to be disconnected to what I\u2019d learned during the first half. Though, the tutorial questions where you have to design the circuits (except sequential circuit) were really fun (kind of IQ test).</p> <p>Here comes the last part of the module, and for me, one of the hardest topics: pipelining and cache. Not only do these topics have a lot of content to cover, but the lecturer only spent one week on each, and of course, it was during the last two weeks of the course.</p> <p>Until this part, I had a neutral opinion on this module: the general content was not that bad, slightly annoying, but it\u2019s doable. But you might have forgotten one thing, this is the Prof Aaron module. His exams were pretty infamous. Things started to get downhill when I attempted the PYP for final exams. I still remember myself sitting at CLB and starting to attempt the final PYP, and oh man, what on earth I had to deal with. The final exam was not only tedious to its core, but also consisted of tricky counting questions. Sometimes, I might have more chances of winning a lottery than precisely counting the number of cache hits and tracing pipelining clock cycles. I knew that there had been a lot of complaints regarding the exam design, but I didn\u2019t expect it to be this bad. Luckily, I had some friends taking this module, making the grinding process more doable. After finishing the finals, my opinion on this module is downright negative. Personally, I found this year's paper slightly more difficult than PYP. I didn\u2019t finish the paper on time.</p> <p>There are a lot of things that could be improved in the next iterations of this module. I don\u2019t think it\u2019s a good idea to teach students MIPS a long while ago before reintroducing the concept at the end of the semester with pipelining. Other than that, the teaching quality is really great and I do not have any issues with it. For the exam, considering the fact that this had been a point of complaint for a while and the lecturer hadn't attempted to resolve the issue, maybe it was actually difficult to create an exam that truly assesses student understanding in two hours. Maybe it's not a bad thing to leave the nature of the course as it is.</p> <p>It\u2019s for me one of the most memorable modules as a freshman :)</p>"},{"location":"blogs/NUS_modules_review/#cs2106-introduction-to-operating-systems","title":"CS2106 Introduction to Operating Systems","text":"<p>Both lecturers are pretty good at teaching. Prof Colin sometimes sidetracked talking about how x86 and memory management file system works which I really like. I felt like both profs really care about students.</p> <p>Content: Same as below. However, the teaching team decided to remove disk scheduling and file system implementation (ext2) this semester.</p> <p>Tutorial: The questions are tricky at times. For me, the first tutorial (on process abstraction) was the hardest. Do practice both in-class questions and the optional ones since they are likely the types of questions you would encounter during exams.</p> <p>Labs: The most time-consuming part of this course. There are four labs in this semester: basic C programming (linked list, hash table), creating your own shell, using synchronisation primitives to solve problems, and implementing memory allocator. Despite spending 3 - 5 hours (ymmv) on each lab, I learned a lot from them.</p> <p>Exam: The questions were mostly well set with some questionable wording at times (especially MCQ questions). The final exam was mostly about file system with a lot of calculations (rlly give me CS2100 vibes but easier).</p> <p>Despite being a CS2100 hater, CS2106 is one of my favourite 2k mods. Do take it quick if your planned focus area is Parallel Computing or Computer Security.</p> <p>TLDR: Fun mod. Labs were tricky. Practice tutorial questions a lot to prepare for exams.</p>"},{"location":"blogs/NUS_modules_review/#cs3230-design-and-analysis-of-algorithms","title":"CS3230 Design and Analysis of Algorithms","text":"<p>Lectures were great. Despite the content basically following CLRS with better visualisation, I still captivated to enter the lecture. The discord server was pretty active, and the professors' dedication to addressing all questions was unmatched.</p> <p>There are three written assignments (asymptotic analysis, amortised analysis and problem reduction, NP-Completeness) and two programming assignments (basically LeetCode with some writings) The last written assignment is optional if your CA is already full.</p> <p>I felt like the exam was somehow unbalanced. For example, during finals, the NP-reduction question required some sort of Math-level of intelligence, but the DP question was straightup giveaway.</p>"},{"location":"blogs/NUS_modules_review/#cs2103t-software-engineering","title":"CS2103T Software Engineering","text":"<p>I felt like this mod is not that bad as it seems.</p> <p>iP is not that big of a deal, but the nature of breath-first iterative approach was irritating. tP, on the other hand, is manageable (and fun) if your team is good and you know what you are supposed to do.</p> <p>As mentioned by other reviewers, the content itself is mostly fluff. I always want to sleep after reading through the textbook for like 10 minutes. May be coffee might help here \u2615 :) I wouldn't say the content is useless because I learned a lot of new things (UML, design pattern). It's just boring (my problem I guess).</p> <p>However, my main gripe with this module is the requirement to go through the content of each week (around 10 - 30 pages of textbook) and answer the weekly quiz. It is so annoying how nitpicking these questions are, and don't forget that you have to do all of these concurrently with iP or tP. It's better to remove the weekly quiz entirely imo.</p> <p>Overall, be open-minded before taking this module.</p>"},{"location":"blogs/running/","title":"My running journey","text":"<p>Midterms are over! Time to paint the town red! But where are you going to celebrate? Umm... I\u2019m not going to a party or hanging out or anything like that. I\u2019m literally going to paint the town red\u2014well, the town of Singapore, that is. But how?</p> <p>You might be wondering how I \"paint\" the country. Obviously, I don't actually paint it\u2014that would be illegal! Instead, I digitally map my routes using a running app called Strava. It tracks your running (and other activity) routes and compiles them into a personal heatmap, showing all the paths, you've covered.</p> <p>Here\u2019s a snapshot of my trails so far, as of 21st March 2025:</p> <p></p> <p>The trails stretch from the west to the east, with a few areas up north. The northwest part of the country remains unexplored\u2014for now. It\u2019s incredibly satisfying to see the result after half a year of effort. But how did it all begin?</p>"},{"location":"blogs/running/#my-first-journey","title":"My first journey","text":"<p>On a regular basis, I usually run at West Coast Park three times a week to exercise and relax. At the time, I disliked doing mindless tasks\u2014like sweeping floors\u2014so it was no surprise that I found West Coast Park painfully boring. My first \"painting\" venture began with a random thought during one of my runs at West Coast Park. I decided to run a bit farther to explore what lay beyond the west. The first destination that came to mind was Jurong East (EW24), which isn\u2019t far from campus (about 8 km) and has an MRT station for the return trip.</p> <p>Although the run was genuinely exhausting\u2014it was the first time I\u2019d managed to cover more than 5 km\u2014the experience was surprisingly fun. Exploring new places has always fascinated me, and that\u2019s when I started venturing out even further. After that day, I started exploring other places within an 8\u201310 km radius, such as HarbourFront and Marina Bay (yes, they\u2019re not that far from my campus). By that point, the southern part of the country had been painted.</p>"},{"location":"blogs/running/#journey-to-the-west","title":"Journey to the west","text":"<p>How about the West? That\u2019s a completely different story.</p> <p>My second journey to the West\u2014Jurong East was my first\u2014started from West Coast Park. I looped around Pandan Reservoir, passed through Jalan Buroh, headed north on Corporation Road, ran along Boon Lay Way, and ended up at Pioneer MRT (EW28), four stations from Jurong East. That was the first 15 km I had ever run in my life, just 6 km short of a half marathon.</p> <p>I ended up running to NTU after all, adding another 2 km and surprising my friend. I stayed there for an hour and almost miss the last bus.</p> <p>Running to the West was no joke; it was extremely difficult and mentally draining for me. What makes running to the East so captivating is its colorful and lively atmosphere\u2014there\u2019s just so much to see. Compared to that, the West has little more than industrial buildings.</p> <p>It took me a month after that run to finally reach Tuas Link (EW33), the last MRT station on the East-West line, completing the West with a total distance of 22 km.</p>"},{"location":"blogs/running/#journey-to-the-east","title":"Journey to the east","text":"<p>The reason it took a month to complete the West was because I decided to focus on the eastern part instead. A week after running to NTU, I completed my first half marathon by running to Marina Bay, crossing the Benjamin Sheares Bridge, and stopping after about 5 km in East Coast Park\u2014at McDonald\u2019s. While the East is more lively, the problem with finishing it is that it\u2019s so damn long. For comparison, East Coast Park alone is already 15 km. There had to be a better strategy to complete the East, right? The issue, unsurprisingly, rooted from my original route to Marina Bay. At that time, I took a 14 km path via HarbourFront (CC29), adding an unnecessary 2\u20133 km by heading too far south. Instead, I could\u2019ve taken the Alexandra Park Connector and passed through Clarke Quay, reducing the distance to around 12 km. After realizing this, I decided to give it another shot. This time, I managed to run 23 km, reaching Bayshore (TE29)\u2014the last TE station to date\u2014just 7 km short of completing the East. The grind continued, but more often than not, I\u2019d end up at McDonald\u2019s (18 km) or Bayshore (23 km). The problem with going further is that once you pass Bayshore, it\u2019s not easy to return\u2014there are no MRT stations in between. The next one is Changi Airport, 7 km away. When I arrived at Bayshore, my legs were numb and my feet in pain. I nearly had to stop. Even though East Coast Park is vibrant, that liveliness fades after Bayshore. What follows is just long stretches of dull parkland\u2014it gave me serious West Coast Park flashbacks. Still, I kept reminding myself: this was my only chance to conquer the East. That day, I decided to push farther, running through East Coast Park G and H, counting sheep in my head to stay sane. I reached Changi Coast Walk at 26 km, thinking I was done\u2014after all, it\u2019s the end of East Coast Park.</p> <p>But then reality hit: I still had almost 4 km to go. I nearly gave up. But you know how these stories end. I pushed through Changi Jurassic Park and, finally, made it to Changi Airport\u201430 km in total. By then, the entire southern coast was complete. I was genuinely proud of myself. I never thought I\u2019d run eighteen miles. I\u2019d come a long way since that first run to Jurong East. It was 10:30 PM\u2014three and a half hours from my starting point. I had hoped to relax at the airport but instead had to rush back to campus\u2014a journey of an hour and a half\u2014before it got too late. My journey concluded at Supersnack, where I rewarded myself with a waffle after completing my first 30 km run.</p>"},{"location":"blogs/running/#whats-next","title":"What\u2019s next?","text":"<p>The rest of my runs were not as interesting. Most of my runs were started from my campus, except the journey to north east (NE17) that I\u2019d started from Botanic Gardens (CC19/DT9), which is a story for another time. Another plan that has come to my mind just now is to run from Tuas Link (EW33) to Changi Airport (CG2), a 52 km run. This might be too difficult for me, so I may decide to focus on the northeastern part of the country first.</p>"},{"location":"blogs/running/#final-thoughts","title":"Final thoughts","text":"<p>Running long distances is definitely tough, and I have a lot of respect for people who manage to finish a full marathon (42 km). While running may be painstakingly boring at first, I reimagined it as painting, which motivated me to continue one of the most boring sports ever for months. It\u2019s so satisfying to see the final art piece after half-year of work. One takeaway I want you to have from this story is the importance of finding purpose or goals in your work. Even when the work is challenging or tedious, you can discover its enjoyment and appreciate the process.</p>"},{"location":"blogs/stepper/","title":"Reimplementing stepper","text":"<p>Have you ever been in a situation where you have to teach students how to learn programming? One of the key aspects that make programming fun is to visualize what\u2019s going on in a piece of program. A stepper solves this problem.</p> <p>The stepper is a tool that helps students visualize step-by-step execution of programs. The stepper has been used in CS1101S, one of the introductory programming courses, and it\u2019s been proven to be effective to students. The stepper uses the philosophy of keep reducing and substituting until you cannot do anything about the program. Here are some examples.</p> <ul> <li>Simple Expression <code>3 + (4 * 7) =&gt; 31</code> <code>3 + (4 * 7) =&gt; 3 + 28 =&gt; 31</code></li> <li>Constant declaration <code>const x = 3; x + 1; =&gt; 5</code> <code>const x = 3; x + 1;</code> <code>4 + 1;</code> <code>5; (Terminate)</code> </li> </ul> <p>For more details, you can refer the implementation details here.</p> <p>However, things start to get a little bit tricky when we substitute function with recursion. The previous version eagerly substitutes functions with recursion which is not great and it\u2019s very tricky to resolve in the previous version. Moreover, after substituting function declaration, the definition of the function is lost. For instance, consider the implementation of factorial.</p> <p><pre><code>const fact = n =&gt; n === 1 ? 1 : n * fact(n - 1);\n</code></pre> What would happen if we call factorial of 5?</p> <pre><code>(n =&gt; n === 1 ? 1 : n * fact(n - 1))(5)\n</code></pre> <p>You can clear see that even though function fact has already been substituted, there should be no fact left in the program, since we cannot recall the definition of fact later on after substitution.</p> <p>One technique that we use is utilizing \\(\\mu\\) term to remember function definition after substitution.</p> <p>(To be continued)</p>"},{"location":"blogs/algo-dump/min-max-path/","title":"Minimizing the sum of the minimum and maximum edge weights along a path.","text":"<p>Source: Codeforce 2117G - Omg Graph</p> <p>Our goal is to find the path that minimize the cost, which is defined as the sum of the minimum and maximum edge weights along a path from node \\(1\\) to \\(n\\), \\(C = \\min_{i = 1}^{k} w_i + \\max_{i = 1}^{k}w_i\\).</p> <p>The tricky part is that the path we are interested in is not necessarily simple (allowing repeated vertices and edges). You can sidetrack yourself by visiting minimum edge weight to lower the value of \\(\\min_{i = 1}^{k} w_i\\). For example, consider this graph.</p> <p><pre><code>%%{init: {'theme': 'default', 'flowchart': { 'useMaxWidth': true, 'htmlLabels': true }}}%%\ngraph LR\n    A((1)) ---|1| B((2))\n    B ---|10| C((3))\n    C ---|2| A</code></pre> If the path is simple, it is trivial that the minimum cost path is \\(1 \\rightarrow 3\\) with the cost of \\(2 + 2 = 4\\). However, since repeated vertices are allowed, you can walk from \\(1 \\rightarrow 2 \\rightarrow 1\\) before \\(1 \\rightarrow 3\\). The total cost is \\(1 + 2 = 3\\).</p> <p>There are many solutions to this problem. However, the approach that I came up (sadly not during contest) is quite similar to Kruskal's algorithm.</p>"},{"location":"blogs/algo-dump/min-max-path/#intuition","title":"Intuition","text":"<p>For a graph \\(G\\), we use a tree subgraph \\(T\\) to represent the path of interest. Without simple path constraint, the minimum/maximum edge weights along the path is simply the minimum edge of \\(T\\). For example, traversing \\(1 \\to 2 \\to 1 \\to 4 \\to 5 \\to 4 \\to 1 \\to 6 \\to 7 \\to 8\\) will give us this tree. The minimum edge weight is \\(4\\). <pre><code>%%{init: {'theme': 'default', 'flowchart': { \n    'useMaxWidth': true, 'htmlLabels': true }}}%%\ngraph LR\n    1((1)) ---|6| 2((2))\n    2 ---|5| 3((3))\n    3 ---|6| 8((8))\n    1 ---|7| 4((4))\n    4 ---|4| 5((5))\n    5 ---|7| 8\n    1 ---|5| 6((6))\n    6 ---|5| 7((7))\n    7 ---|5| 8\n    linkStyle 6 stroke:#0f0,stroke-width:2px\n    linkStyle 7 stroke:#0f0,stroke-width:2px\n    linkStyle 8 stroke:#0f0,stroke-width:2px\n    linkStyle 0 stroke:#0f0,stroke-width:2px\n    linkStyle 3 stroke:#0f0,stroke-width:2px\n    linkStyle 4 stroke:#0f0,stroke-width:2px\n</code></pre></p> <p>One naive (and impractical) way of solving this problem is by going through all possible tree subgraphs that contain node \\(1\\) and \\(n\\). This is impossible since the number of tree subgraphs grows exponentially with the number of nodes. (Spanning trees already take \\(n^{n - 2}\\) possibilities.)</p> <p>One simple trick that save us is constraining our graph maximum edge \\(w_{max}\\). If \\(w_max\\) is too small, node \\(1\\) and node \\(n\\) are disconnected. So we have to crank up \\(w_{max}\\) until node \\(1\\) and node \\(n\\) are connected. Alternatively, we sort the edges based on weights from small to large. Then, start adding new edges until node \\(1\\) and node \\(n\\) are connected.  This approach is similar to Kruskal's algorithm and can be achieved by using Disjoint Set Union (DSU).</p> <p>Throughout the process, we can augment the minimum edge and maximum edge weights of each component and update every time we perform union operation. </p> <p>If node \\(1\\) and node \\(n\\) are in the same component, we could calculate the cost (simply adding minimum and maximum edges augmented in the component) can call it a day. However, we should continue adding new edges, as some high-weight edges may unlock new minimum-weight edges during the process. So, we have to track the mininum cost and only halt when the weight of the new edge alone is larger than the minimum cost.   </p> <p>The time complexity of this solution is \\(O(E \\log{E})\\) since we have to sort the edges. The time taken in DSU is \\(O(E \\cdot \\alpha{(n)})\\) which is small compared to sorting time.</p>"},{"location":"blogs/algo-dump/min-max-path/#code","title":"Code","text":"<pre><code>#define vi vector&lt;int&gt;\n#define M 1000000007\n#define P 31\n#define N 64\n\nvoid solve() {\n    int n, m; cin &gt;&gt; n &gt;&gt; m;\n    map&lt;int, map&lt;int, int&gt;&gt; dist;\n    vii e;\n    for (int i = 0; i &lt; m; i++) {\n        int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; u--; v--;\n        dist[u][v] = w; dist[v][u] = w;\n        e.push_back({w, u, v});\n    }\n    sort(e.begin(), e.end());\n    vi dsu(n, -1);  vi rank(n, 1); \n    vi minEdge(n, INT_MAX);\n    vi maxEdge(n, -1);\n    for (int i = 0; i &lt; n; i++) dsu[i] = i;\n    function&lt;int(int)&gt; find_dsu = [&amp;](int u){\n        if (u == dsu[u]) return u;\n        dsu[u] = find_dsu(dsu[u]);\n        return dsu[u];\n    };\n    function&lt;void(int, int)&gt; union_dsu = [&amp;](int u, int v) {\n        int a = find_dsu(u); \n        int b = find_dsu(v);\n        if (a == b) return;\n        if (rank[a] &gt; rank[b]) {\n            swap(a, b);\n        }\n        dsu[a] = b; \n        rank[b] += rank[a]; \n        int mn = min(minEdge[a], minEdge[b]); \n        mn = min(mn, dist[u][v]);\n        int mx = max(maxEdge[a], maxEdge[b]);\n        mx = max(mx, dist[u][v]);\n        minEdge[a] = minEdge[b] = mn;\n        maxEdge[a] = maxEdge[b] = mx;\n        return;\n    };\n    int mx = -1; int ans = INT_MAX;\n    for (int i = 0; i &lt; e.size(); i++) {\n        vi E = e[i];\n        union_dsu(E[1], E[2]);\n        if (find_dsu(0) == find_dsu(n - 1)) {\n            mx = E[0]; if (mx &gt; ans) break;\n            ans = min(ans, mx + minEdge[find_dsu(0)]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; \"\\n\";\n}\n\nint main() {  \n    int tc; cin &gt;&gt; tc;\n    while (tc--) solve();\n    return 0;\n}\n</code></pre>"}]}